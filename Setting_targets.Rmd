---
title: 'Setting targets in anaemia'
---

This markdown file describes the analysis plan for the secondary target setting paper.  
The paper will essentially show how target setting can be done using league tables of viable interventions, with a country's cost per YLD averted. This will prioritise an intervention to be done first up to the maximum viable coverage, then remove it from the list and repeat the league table exercise until all interventions are applied, costs are too high, or cost-effectiveness is not achievable.  

The visualisation plan is for league tables by region, with regions as facets on the Y-axis (vertical), and cost/DALY on the X-axis (horizontal) with a dashed line for each facet denoting the regional WTP and a density plot for each distribution of cost/YLD by simulation.

```{r, warning = FALSE, message = FALSE}
options(scipen = 999, digits = 5)

library(vroom)
library(countrycode)
library(EnvStats)
library(zoo)
library(tidyverse)
library(scales)

source("./99_Functions.R")

# Read in 2030 population estimates
df_2030 <- readRDS("./Data/est_2030.rds")

# Using 10,000 iterations
iter <- 10000

# Maximum possible coverage is 100% in this example
# Note that if actual coverage > maximum coverage, there will be negative costs
coverage_max <- 1

# Read in costs, interventions, coverage and filter by compatible countries
source("./1_Interventions.R")
df_2030 <- df_2030 |>
  filter(location_name %in% Reduce(intersect, list(
    df_2030$location_name,
    df_costs$location_name,
    df_coverage$location_name
  )))

# Get full country list
countrylist <- unique(df_2030$location_name)

# YLDs from anaemia:
YLD_mild <- 0.005
YLD_moderate <- 0.053
YLD_severe <- 0.150

# Which WTP threshold to use: lower or upper?
Threshold <- "Upper"
WTP <- df_costs |>
  select(
    location_name,
    paste0(Threshold, "_WTP")
  ) |>
  rename(
    Country = location_name,
    WTP = paste0(Threshold, "_WTP")
  )
```

There are 4 interventions we will consider in this list.  However, the iron supplementation program will be modified depending on the baseline prevalence of anaemia in the population, which affects whether it will be implemented daily or intermittently.
```{r}
# List of interventions:
interventions <- c(
  "Iron_Preg", # Iron and folic acid supplementation in pregnant women
  "Iron_WRA", # Iron supplementation in WRA
  "Fortification", # Staple food supplementation in all individuals
  "Antimalarial" # Antenatal intermittent antimalarials
)
```

The basic structure of the league table idea is as follows:  
- Obtain the cost of each intervention per person and multiply by the increase in eligible population (e.g., pregnant women not currently receiving the intervention)  
- Obtain the effectiveness (RR) of each intervention, enter that into the following formula with given current and maximum coverage:  
$$
\theta = \frac{1 - c_{max}(1 - RR_1)}{1 - c_{current}(1 - RR_0)}
$$
- Now multiply theta by the target population (e.g. pregnant anaemic women) of each type of anaemia: mild, moderate, and severe, and obtain the YLD for each type
- Divide costs by YLD and sort ascending  
- Pick the top option and then remove that intervention from the list  
- Repeat

First we need to do the initial setup. We create a league table for each country, ranking the 6 interventions by cost/YLD:

```{r, warning = FALSE, message = FALSE}
gc()
# Run the simulator function for each intervention:
# Simulator takes prevalence data, country, intervention name, eligible population (for costs) and targeted population (for effects)

# Run analysis for each country
stage0 <- list()
for (i in 1:length(countrylist)) {
  country <- countrylist[i]

  sims <- list(
    # Iron supplementation in pregnant women
    simulator(df_2030, country, interventions[[1]]),
    # Iron supplementation in all WRA
    simulator(df_2030, country, interventions[[2]]),
    # Staple food supplementation for all
    simulator(df_2030, country, interventions[[3]]),
    # Presumptive treatment for malaria in pregnant women
    simulator(df_2030, country, interventions[[4]])
  )

  stage0[[i]] <- do.call(rbind, sims) |>
    group_by(Intervention) |>
    summarise(
      Cost_per_YLD_low = quantile(Cost_per_YLD, 0.025, na.rm = T),
      Cost_per_YLD_high = quantile(Cost_per_YLD, 0.975, na.rm = T),
      Cost_per_YLD = mean(Cost_per_YLD),
      Total_spend = mean(Cost, na.rm = T)
    ) |>
    mutate(Country = country) |>
    relocate(Country, .before = Intervention)
}

cea <- do.call(rbind, stage0) |>
  arrange(Country, Cost_per_YLD) |>
  left_join(WTP)
remove(stage0, sims)
```

This demonstrates which intervention is the most cost-effective for a given country. The purpose of a league table is to identify what a decision-maker should rationally implement first.

Now we can extract the top row for each country and feed this intervention into a loop over every country, provided the proposed intervention is cost-effective.

```{r}
# Identify intervention 1 for each country
int1 <- cea |>
  na.omit() |>
  filter(Cost_per_YLD <= WTP) |>
  group_by(Country) |>
  slice(1)

total_spend <- int1 |>
  select(Country, Total_spend) |>
  rename(Total_spend_1 = Total_spend)

# Apply intervention 1 to each country if cost-effective using applicator function
# Applicator function takes the above intervention table and extracts the intervention, then applies it to the baseline data provided
df_stage1 <- apply_intervention(base_data = df_2030, cea_table = int1)
```

Now we can have an updated dataset of our expected prevalence of each type of anaemia across each population of interest.
This lets us re-do the simulator function to obtain an updated cost-effectiveness table, less the intervention we just applied.

```{r, warning = FALSE}
gc()
cea0_1 <- cea |>
  group_by(Country) |>
  slice(-1) |>
  select(, 1:2)

stage1 <- list()
for (i in 1:length(countrylist)) {
  country <- countrylist[i]

  sims <- list(
    # Intervention 1
    simulator(df_stage1, country, cea0_1$Intervention[cea0_1$Country == country][1]),
    # Intervention 2
    simulator(df_stage1, country, cea0_1$Intervention[cea0_1$Country == country][2]),
    # Intervention 3
    simulator(df_stage1, country, cea0_1$Intervention[cea0_1$Country == country][3])
  ) # Add interventions 4 and 5 when intermittent iron is available

  stage1[[i]] <- do.call(rbind, sims) |>
    group_by(Intervention) |>
    summarise(
      Cost_per_YLD_low = quantile(Cost_per_YLD, 0.025, na.rm = T),
      Cost_per_YLD_high = quantile(Cost_per_YLD, 0.975, na.rm = T),
      Cost_per_YLD = mean(Cost_per_YLD),
      Total_spend = mean(Cost, na.rm = T)
    ) |>
    mutate(Country = country) |>
    relocate(Country, .before = Intervention) |>
    arrange(Cost_per_YLD)
}

cea1 <- do.call(rbind, stage1) |>
  left_join(WTP)
remove(stage1, sims, cea0_1)
```

Some countries have no more interventions to apply. These can now be removed from the analysis, and the next intervention will be applied to the remaining groups who have cost-effective interventions available.


```{r}
# Identify intervention 2
int2 <- cea1 |>
  na.omit() |>
  filter(Cost_per_YLD <= WTP) |>
  group_by(Country) |>
  slice(1)

total_spend <- int2 |>
  select(Country, Total_spend) |>
  rename(Total_spend_2 = Total_spend) |>
  full_join(total_spend)
  

# Apply intervention 2 to each country
df_stage2 <- apply_intervention(base_data = df_stage1, cea_table = int2)
```

We can now see that some countries have an unchanged prevalence estimate. This is because there are no more cost-effective interventions that can be done, or they simply are not able to apply them (e.g. the population does not eat a fortifiable staple food). We now get an updated CEA table following two interventions:

```{r, warning = FALSE}
gc()

cea1_2 <- cea1 |>
  group_by(Country) |>
  slice(-1) |>
  select(, 1:2)

stage2 <- list()
for (i in 1:length(countrylist)) {
  country <- countrylist[i]

  sims <- list(
    # Intervention 1
    simulator(df_stage2, country, cea1_2$Intervention[cea1_2$Country == country][1]),
    # Intervention 2
    simulator(df_stage2, country, cea1_2$Intervention[cea1_2$Country == country][2])
  ) # Add interventions 3 and 4 when intermittent iron is available

  stage2[[i]] <- do.call(rbind, sims) |>
    group_by(Intervention) |>
    summarise(
      Cost_per_YLD_low = quantile(Cost_per_YLD, 0.025, na.rm = T),
      Cost_per_YLD_high = quantile(Cost_per_YLD, 0.975, na.rm = T),
      Cost_per_YLD = mean(Cost_per_YLD),
      Total_spend = mean(Cost, na.rm = T)
    ) |>
    mutate(Country = country) |>
    relocate(Country, .before = Intervention) |>
    arrange(Cost_per_YLD)
}

cea2 <- do.call(rbind, stage2) |>
  left_join(WTP)
remove(stage2, sims, cea1_2)
```

Repeating the apply_intervention() function, we get the new prevalence:

```{r}
# Identify intervention 3
int3 <- cea2 |>
  na.omit() |>
  filter(Cost_per_YLD <= WTP) |>
  group_by(Country) |>
  slice(1)

total_spend <- int3 |>
  select(Country, Total_spend) |>
  rename(Total_spend_3 = Total_spend) |>
  full_join(total_spend)

# Apply intervention 3 to each country
df_stage3 <- apply_intervention(base_data = df_stage2, cea_table = int3)
```

Most countries now have few or no treatments remaining. Re-applying the simulator function, we get:

```{r}
gc()

cea2_3 <- cea2 |>
  group_by(Country) |>
  slice(-1) |>
  select(, 1:2)

stage3 <- list()
for (i in 1:length(countrylist)) {
  country <- countrylist[i]

  stage3[[i]] <- simulator(df_stage3, country, cea2_3$Intervention[cea2_3$Country == country][1]) |>
    group_by(Intervention) |>
    summarise(
      Cost_per_YLD_low = quantile(Cost_per_YLD, 0.025, na.rm = T),
      Cost_per_YLD_high = quantile(Cost_per_YLD, 0.975, na.rm = T),
      Cost_per_YLD = mean(Cost_per_YLD),
      Total_spend = mean(Cost, na.rm = T)
    ) |>
    mutate(Country = country) |>
    relocate(Country, .before = Intervention) |>
    arrange(Cost_per_YLD)
}

cea3 <- do.call(rbind, stage3) |>
  left_join(WTP)
remove(stage3, cea2_3)
```

Now we can do the final intervention:

```{r}
# Identify intervention 4
int4 <- cea3 |>
  na.omit() |>
  filter(Cost_per_YLD <= WTP) |>
  group_by(Country) |>
  slice(1)

total_spend <- int4 |>
  select(Country, Total_spend) |>
  rename(Total_spend_4 = Total_spend) |>
  full_join(total_spend)

# Apply intervention 4 to each country
# In reality there is no intervention 4; no countries retain cost-effectiveness for the 4th intervention
df_final <- apply_intervention(base_data = df_stage3, cea_table = int4)
```

And that's it! The next part is just visualising the change following the application of all interventions

```{r}
df_change <- df_final |>
  rename(
    Pop_pregnant_anaemic_post = Pop_pregnant_anaemic,
    Pop_pregnant_malaria_anaemic_post = Pop_pregnant_malaria_anaemic,
    Pop_anaemic_post = Pop_anaemic,
    YLD_post = YLD
  ) |>
  full_join(df_2030) |>
  mutate(
    Change_anaemic = Pop_anaemic_post - Pop_anaemic,
    Pct_change_anaemic = Change_anaemic / Pop_anaemic
  ) |>
  rename(
    Pop_pregnant_anaemic_pre = Pop_pregnant_anaemic,
    Pop_pregnant_malaria_anaemic_pre = Pop_pregnant_malaria_anaemic,
    Pop_anaemic_pre = Pop_anaemic,
    YLD_pre = YLD
  )

total_spend <- total_spend %>%
  replace(is.na(.), 0) |>
  mutate(Total_spend_all = 
           Total_spend_1 +
           Total_spend_2 +
           Total_spend_3 +
           Total_spend_4)

final_reduction <- df_change |>
  rename(Country = location_name) |>
  group_by(Country) |>
  summarise(
    anaemic_pre = sum(Pop_anaemic_pre),
    anaemic_post = sum(Pop_anaemic_post)
  ) |>
  mutate(Pct_change_anaemic = (anaemic_pre - anaemic_post) / anaemic_pre) |>
  left_join(total_spend[,c("Country", "Total_spend_all")])

meanval <- paste0("Mean reduction in anaemia = ", round(mean(final_reduction$Pct_change_anaemic), 2))

p <- final_reduction |>
  ggplot()

p +
  geom_histogram(aes(Pct_change_anaemic), binwidth = 0.025) +
  scale_x_continuous(breaks = seq(0, 1, 0.05)) +
  geom_vline(aes(xintercept = mean(Pct_change_anaemic)), colour = "red") +
  annotate("text",
    label = meanval,
    x = mean(final_reduction$Pct_change_anaemic),
    y = 35,
    colour = "red"
  )

p +
  geom_histogram(aes(x = Total_spend_all), binwidth = 25000000) +
  scale_x_continuous(label = comma)

p +
  geom_point(aes(x = Pct_change_anaemic, y = Total_spend_all)) + 
  scale_x_continuous(breaks = seq(0, 1, 0.05)) +
  scale_y_continuous(label = comma) +
  geom_vline(aes(xintercept = mean(Pct_change_anaemic)), colour = "red") +
  annotate("text",
    label = meanval,
    x = mean(final_reduction$Pct_change_anaemic),
    y = 2e9,
    colour = "red"
  ) 
```



